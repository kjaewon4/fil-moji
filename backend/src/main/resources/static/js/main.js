// ÏÑ†ÌÉùÎêú ÌïÑÌÑ∞ Í¥ÄÎ†® Î≥ÄÏàò
let selectedFilter = null;
let selectedFilterName = null;
document.querySelector(".delete-btn").addEventListener("click", clearSelectedImage);

// Ïù¥Î™®ÏßÄ ÌïÑÌÑ∞ ÏÑ†ÌÉù Ìï®Ïàò
function selectedFilterFunc(name) {
    selectedFilter = FILTER_MAP[name];
    selectedFilterName = name;
    console.log("ÏÑ†ÌÉùÎêú ÌïÑÌÑ∞:", name);
}

//Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù Ìï¥Ï†ú
function clearSelectedImage() {
    selectedFilter = null;
    selectedFilterName = null;
    console.log("üîÑ Ïù¥Î™®ÏßÄ ÌïÑÌÑ∞ ÏÑ†ÌÉù Ìï¥Ï†úÎê®");
}

// Ïπ¥Î©îÎùº Ïó∞Í≤∞
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

connectCamera(video);

/**
 * ÏõπÏ∫† Ïó∞Í≤∞ Ìï®Ïàò
 */
function connectCamera(videoElement) {
    navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
            videoElement.srcObject = stream;
        })
        .catch((err) => {
            alert("Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®: " + err);
        });
}

/**
 * Ï¥¨ÏòÅ ÌõÑ Spring ÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ° (ÌïÑÌÑ∞ Ìè¨Ìï®)
 */
async function sendToSpringServer() {
    const isUserLoggedIn = await isLoggedIn();
    if (!isUserLoggedIn) return showLoginModal();

    const canvas = captureVideoToCanvas(video);
    const blob = await canvasToBlob(canvas);

    // 1. ÎπÑÎîîÏò§ ÌîÑÎ†àÏûÑ Ï∫°Ï≤òÏö© ÏûÑÏãú Ï∫îÎ≤ÑÏä§
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = video.videoWidth;
    tempCanvas.height = video.videoHeight;
    const tempCtx = tempCanvas.getContext("2d");

    // 2. ÎπÑÎîîÏò§ Í∑∏Î¶¨Í∏∞
    tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

    // 3. ÎûúÎìúÎßàÌÅ¨ Ï∂îÏ∂ú
    const blobForLandmarks = await canvasToBlob(tempCanvas);
    const landmarks = await getLandmarksFromServer(blobForLandmarks);

    // 4. ÌïÑÌÑ∞ Ïù¥ÎØ∏ÏßÄ Ìï©ÏÑ±
    if (selectedFilter && selectedFilter.src && selectedFilter.landmarkIndex) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = selectedFilter.src;

        await new Promise((resolve) => {
            img.onload = () => {
                let x = 0, y = 0;
                // drawW, drawH Ï¥àÍ∏∞Í∞íÏùÑ FILTER_MAPÏóêÏÑú Ïò® Í∞íÏúºÎ°ú ÏÑ∏ÌåÖ
                let drawW = selectedFilter.width;
                let drawH = selectedFilter.height;

                const { offsetX = 0, offsetY = 0, landmarkIndex } = selectedFilter;

                if (Array.isArray(landmarkIndex)) {
                    const [i1, i2] = landmarkIndex;
                    const p1 = landmarks.find(p => p.index === i1);
                    const p2 = landmarks.find(p => p.index === i2);
                    if (p1 && p2) {
                        x = (p1.x + p2.x) / 2;
                        y = (p1.y + p2.y) / 2;
                        // ÏñºÍµ¥ Í∞Ñ Í±∞Î¶¨ ÎπÑÎ°Ä Ïä§ÏºÄÏùº
                        const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                        const scale = dist / 50 * 2.0;  // Ïã§ÏãúÍ∞ÑÍ≥º ÎèôÏùºÌïú Í∏∞Ï§Ä
                        drawW = drawW * scale;
                        drawH = drawH * scale;

                        console.log(
                            "filter:", selectedFilterName,
                            "dist:", dist.toFixed(1),
                            "scale:", scale.toFixed(2),
                            "drawW√ódrawH:", Math.round(drawW), "√ó", Math.round(drawH)
                        );

                    }
                } else {
                    const p = landmarks.find(p => p.index === landmarkIndex);
                    if (p) {
                        x = p.x;
                        y = p.y;
                    }
                }

                // Ïã§Ï†úÎ°ú ÌïÑÌÑ∞ Í∑∏Î¶¨Í∏∞
                tempCtx.drawImage(
                    img,
                    x + offsetX - drawW / 2,
                    y + offsetY - drawH / 2,
                    drawW,
                    drawH
                );
                resolve();

            };
        });
    }

    // 5. ÏµúÏ¢Ö Ïù¥ÎØ∏ÏßÄ blobÏúºÎ°ú Î≥ÄÌôò (ÌïÑÌÑ∞ Ìè¨Ìï®Îêú ÏÉÅÌÉú)
    const finalBlob = await canvasToBlob(tempCanvas);
    if (!finalBlob) {
        console.error("üìõ finalBlobÏù¥ nullÏûÖÎãàÎã§. Ï∫îÎ≤ÑÏä§Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.");
        return;
    }
    // 6. Ï†ÑÏÜ°
    const filterInfo = {
        emoji: selectedFilterName || "none",
        position: selectedFilter
            ? landmarkIndexToPosition(selectedFilter.landmarkIndex)
            : "unknown",
        src: selectedFilter.src || "none"
    };

    const formData = new FormData();
    formData.append("file", finalBlob, "capture.jpg");
    formData.append("filterInfo", JSON.stringify(filterInfo));

    const res = await fetch("http://localhost:8080/api/photos/upload", {
        method: "POST",
        body: formData
    });

    const result = await res.json();
    console.log("üì∏ Spring ÏùëÎãµ:", result.message);
}

/**
 * Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌôïÏù∏
 */
async function isLoggedIn() {
    const res = await fetch("http://localhost:8080/api/auth/check", {
        method: "GET",
        credentials: "include"
    });
    return res.ok;
}

/**
 * Î°úÍ∑∏Ïù∏ Î™®Îã¨ ÌëúÏãú
 */
function showLoginModal() {
    const modal = document.getElementById("loginModal");
    modal.style.display = "block";
}

/**
 * Î°úÍ∑∏Ïù∏ Î™®Îã¨ Îã´Í∏∞
 */
function closeModal() {
    const modal = document.getElementById("loginModal");
    modal.style.display = "none";
}

/**
 * ÎπÑÎîîÏò§Î•º Ï∫îÎ≤ÑÏä§Î°ú Ï∫°Ï≤ò
 */
function captureVideoToCanvas(videoElement) {
    const tempCanvas  = document.createElement("canvas");
    tempCanvas.width = videoElement.videoWidth;
    tempCanvas.height = videoElement.videoHeight;

    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
    return tempCanvas;
}

/**
 * Ï∫îÎ≤ÑÏä§Î•º BlobÏúºÎ°ú Î≥ÄÌôò
 */
function canvasToBlob(canvas) {
    return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob), "image/jpeg");
    });
}

/**
 * ÎûúÎìúÎßàÌÅ¨ Ïù∏Îç±Ïä§Î•º ÏúÑÏπò Ïù¥Î¶ÑÏúºÎ°ú Îß§Ìïë (ÌòÑÏû¨ ÎØ∏ÏÇ¨Ïö©)
 */
function landmarkIndexToPosition(index) {
    if (Array.isArray(index)) {
        const [i1, i2] = index;
        // Îàà ÏúÑÏπò
        if ((i1 === 33 && i2 === 263) || (i1 === 362 && i2 === 133)) {
            return "eyes";
        }
    }

    switch (index) {
        case 1:
        case 6:
        case 9:
        case 10:
            return "forehead";
        case 168:
            return "topHead";
        case 197:
        case 5:
            return "nose";
        case 152:
            return "chin";
        default:
            return "face";
    }
}

/**
 * FastAPI ÏöîÏ≤≠
 */
async function getLandmarksFromServer(blob) {
    const formData = new FormData();
    formData.append("file", blob, "frame.jpg");

    try {
        const res = await fetch("http://localhost:8000/api/landmark", {
            method: "POST",
            body: formData,
        });

        if (!res.ok) {
            console.error("ÏÑúÎ≤Ñ Ïò§Î•ò ÏùëÎãµ:", await res.text());
            return null;
        }

        const json = await res.json();
        return json.faces?.[0] ?? [];

    } catch (e) {
        console.error("ÎûúÎìúÎßàÌÅ¨ ÏöîÏ≤≠ Ï§ë ÏòàÏô∏ Î∞úÏÉù:", e);
        return null;
    }

}

/**
 * Ï∫îÎ≤ÑÏä§Ïóê Ï¢åÌëú Î†åÎçîÎßÅ (ÌïÑÌÑ∞)
 */
function drawLandmarksOnCanvas(landmarks) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    landmarks.forEach(p => {
        ctx.beginPath(); // ÏÉàÎ°úÏö¥ Í≤ΩÎ°ú ÏãúÏûë
//        ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);  // x, y Ï¢åÌëúÏóê Î∞òÏßÄÎ¶Ñ 2ÏßúÎ¶¨ ÏõêÏùÑ Í∑∏Î¶º
//        ctx.fillStyle = "red";
//        ctx.fill();
//
//        // ÎîîÎ≤ÑÍ∑∏ ÌÖçÏä§Ìä∏
//        ctx.fillStyle = "white";
//        ctx.font = "10px Arial";
//        ctx.fillText(p.index, p.x + 4, p.y - 4);
    })
}

/**
 * Ïã§ÏãúÍ∞Ñ Î£®ÌîÑ
 */
async function processLoop() {
    const canvasTemp = captureVideoToCanvas(video);

    canvasTemp.toBlob(async (blob) => {
        try {
            const landmarks = await getLandmarksFromServer(blob);
            drawFilterOnCanvas(landmarks);     // ‚Üê ÏàúÏÑú Ï§ëÏöî
            drawLandmarksOnCanvas(landmarks);  // ‚Üê Ï†ê ÏúÑÏóê Ï∞çÌûàÍ≤å
        } catch (e) {
            console.log("ÏñºÍµ¥ ÏóÜÏùå:", e.message);
        }
        requestAnimationFrame(processLoop);
    }, "image/jpeg");
}

// ÏµúÏ¥à Ïã§Ìñâ
window.addEventListener("DOMContentLoaded", () => {
    navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
            video.srcObject = stream;
            requestAnimationFrame(processLoop); // Î£®ÌîÑ ÏãúÏûë
        })
        .catch((err) => {
            alert("Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®: " + err.message);
        });
});

/**
 * ÌïÑÌÑ∞ Í∑∏Î¶¨Í∏∞
 */
function drawFilterOnCanvas(landmarks) {
    if (!selectedFilter || !selectedFilter.src || !selectedFilter.landmarkIndex) return;

    const { src, landmarkIndex, offsetX = 0, offsetY = 0, width = 50, height = 50 } = selectedFilter;
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = src;

    img.onload = () => {
        let x = 0, y = 0;

        if (Array.isArray(landmarkIndex)) {
            const [i1, i2] = landmarkIndex;
            const p1 = landmarks.find(p => p.index === i1);
            const p2 = landmarks.find(p => p.index === i2);
            if (!p1 || !p2) return;

            // Ï§ëÏã¨ Ï¢åÌëú
            x = (p1.x + p2.x) / 2;
            y = (p1.y + p2.y) / 2;

            // Í±∞Î¶¨ Í≥ÑÏÇ∞ (Ïú†ÌÅ¥Î¶¨Îìú Í±∞Î¶¨)
            const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

            // ÌïÑÌÑ∞ ÌÅ¨Í∏∞ ÎπÑÎ°Ä Ï°∞Ï†ï (Í∏∞Ï§Ä Í±∞Î¶¨ 50 Í∏∞Ï§Ä)
            const scale = dist / 50 * 2.0;
            const scaledWidth = width * scale;
            const scaledHeight = height * scale;

            ctx.drawImage(img, x + offsetX - scaledWidth / 2, y + offsetY - scaledHeight / 2, scaledWidth, scaledHeight);

        } else {
            const point = landmarks.find(p => p.index === landmarkIndex);
            if (!point) return;
            x = point.x;
            y = point.y;

            ctx.drawImage(img, x + offsetX - width / 2, y + offsetY - height / 2, width, height);
        }
    };
}




